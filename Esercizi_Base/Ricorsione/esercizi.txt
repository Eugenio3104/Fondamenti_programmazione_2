5 Esercizi di Base (Riscaldamento)Questi esercizi servono a padroneggiare il caso base e la riduzione dell'input.

Somma dei Cifre: Scrivi una funzione int sumDigits(int n) che restituisce la somma delle cifre di un numero (es. $123 \to 1+2+3 = 6$).

Stringa Inversa: Scrivi una funzione void reversePrint(string s) che stampa una stringa al contrario senza usare cicli, ma sfruttando la posizione del cursore nello stack.

Massimo in un Array: Scrivi int findMax(int arr[], int n) che trova il valore massimo in un array di dimensione $n$ confrontando l'elemento corrente con il massimo del "resto dell'array".

Potenza Ricorsiva: Implementa int power(int base, int exp) che calcola $base^{exp}$. Bonus: prova a farlo in $O(\log n)$ (Binary Exponentiation).

Conteggio Occorrenze: Scrivi una funzione che conti quante volte un carattere c appare in una stringa usando la ricorsione.


Il Cruciverba Impossibile (Target Sum con Operatori)Data una lista di numeri, ad esempio {1, 2, 3} e un valore Target (es. 0), verifica se è possibile ottenere il target inserendo i segni + o - tra i numeri.Esempio: 1 - 2 + 3 = 2 (No), 1 + 2 - 3 = 0 (Sì!).Perché è tricky: Non stai solo scegliendo se prendere un numero, ma stai decidendo quale operazione applicare. La tua funzione deve ramificarsi in due: una che somma il numero corrente e una che lo sottrae.

Anagrammi con Vincoli (Unique Permutations)Data una stringa che può contenere caratteri duplicati (es. "AAB"), genera tutte le permutazioni uniche.Esempio: Dovrebbe restituire AAB, ABA, BAA, ma non duplicare AAB due volte.Perché è tricky: La ricorsione classica delle permutazioni genera duplicati. Qui devi aggiungere una logica di controllo (o un ordinamento preventivo) per "potare" i rami della ricorsione che porterebbero a risultati identici.

Sudoku Solver (Il Re del Backtracking)Data una griglia $9 \times 9$ parzialmente riempita, scrivi una funzione che la risolva completamente.Perché è tricky: È l'essenza della ricorsione distruttiva/costruttiva. Devi provare un numero da 1 a 9, controllare se è valido, passare alla cella successiva e, se rimani bloccato, tornare indietro e cancellare il numero appena messo per provarne un altro.

Il Problema della Scomposizione (Integer Partition)Dato un intero $n$, stampa tutti i modi in cui può essere scritto come somma di interi positivi.Esempio: Per $n=4$:43+12+22+1+11+1+1+1Perché è tricky: Devi passare alla funzione un parametro "limite" per evitare di stampare duplicati come 3+1 e 1+3. Ogni numero scelto condiziona le scelte massime dei passi successivi.

Stringhe di Josephus (o Eliminazione Circolare)Ci sono $n$ persone in cerchio. Partendo dalla prima, ogni $k$-esima persona viene eliminata. Chi rimane per ultimo?Sfida: Risolvilo con una funzione ricorsiva pura che non usi liste o array per simulare il cerchio, ma solo una formula ricorsiva che riduca il problema da $n$ persone a $n-1$.Perché è tricky: Ti costringe a trovare la relazione matematica tra la posizione del vincitore con $n$ persone e quella con $n-1$. È pura logica di riduzione.